# JS 的执行机制

::: tip JS 的执行
关于 JS 的执行机制这里其实还是蛮重要的
:::

## JS 的异步执行

::: tip 异步执行
JS 的异步执行
:::

Javascript 是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个，主线程承担着诸多的工作渲染页面之外，执行 JS 都在其中

如果使用同步的方式，就有可能导致主线程产生阻塞，从而导致消息队列中许多其他任务无法得到执行，这样一来，一方面导致繁忙的主线程白白浪费时间，另一方面导致页面无法及时更新给用户造成卡死现象

所以，浏览器才使用一步的方式来避免，具体的做法便是当某些任务发生时，比如计时器，网络，时间监听。

主线程将任务交给其他线程去处理，（那什么是其他线程呢，比如网络线程，渲染线程，计时器线程等等），自身立即结束任务的执行，转而后续代码，当其他线程完成时，将实现传递的回调函数包装成任务加入消息队列的末尾，等待主线程调度执行，在这种异步模式下，浏览器就不会发生阻塞，从而保证了单线程的流畅运行

## EventLoop（事件循环）

::: tip EventLoop，JS 精髓所在
这里其实在面试过程中还是比较常见的一个问题，也是 JS 的之所以是 JS 的一个解释吧
:::

相信这个问题在面试过程中也是被问的最多的一个，那到底是什么才是事件循环呢，这中间有发生了什么？

事件循环又被称为消息循环（message queue），是浏览器主线程的一种方式

在 Chorme 内部会开启一个永不结束的 for 循环，每次循环都会从消息队列中取第一个任务执行，而其他线程只需要在合适的时间将任务添加到队列的末尾，这里的其他线程，就是我们之前说到的网络请求，定时器等

在消息队列中，每一个任务都有不同的类型，同类型的任务必须在同一个队列（就比如，网络请求，就会放在网络请求的队列），不同的任务属于不同的队列，不同的任务有不同的优先级，在一次时间循环中，有浏览器决定哪一个队列的任务执行，但是浏览器必须有用完微任务队列，微任务有一定的优先级。
