import{_ as e,c as a,o as t,O as o}from"./chunks/framework.37ff8a7b.js";const u=JSON.parse('{"title":"JS 的执行机制","description":"","frontmatter":{},"headers":[],"relativePath":"JS/1.eventlLoop.md"}'),r={name:"JS/1.eventlLoop.md"},p=o('<h1 id="js-的执行机制" tabindex="-1">JS 的执行机制 <a class="header-anchor" href="#js-的执行机制" aria-label="Permalink to &quot;JS 的执行机制&quot;">​</a></h1><h2 id="js-的异步执行" tabindex="-1">JS 的异步执行 <a class="header-anchor" href="#js-的异步执行" aria-label="Permalink to &quot;JS 的异步执行&quot;">​</a></h2><p>Javascript 是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个，主线程承担着诸多的工作渲染页面之外，执行 JS 都在其中</p><p>如果使用同步的方式，就有可能导致主线程产生阻塞，从而导致消息队列中许多其他任务无法得到执行，这样一来，一方面导致繁忙的主线程白白浪费时间，另一方面导致页面无法及时更新给用户造成卡死现象</p><p>所以，浏览器才使用一步的方式来避免，具体的做法便是当某些任务发生时，比如计时器，网络，时间监听。</p><p>主线程将任务交给其他线程去处理，（那什么是其他线程呢，比如网络线程，渲染线程，计时器线程等等），自身立即结束任务的执行，转而后续代码，当其他线程完成时，将实现传递的回调函数包装成任务加入消息队列的末尾，等待主线程调度执行，在这种异步模式下，浏览器就不会发生阻塞，从而保证了单线程的流畅运行</p><h2 id="eventloop-事件循环" tabindex="-1">EventLoop（事件循环） <a class="header-anchor" href="#eventloop-事件循环" aria-label="Permalink to &quot;EventLoop（事件循环）&quot;">​</a></h2><p>相信这个问题在面试过程中也是被问的最多的一个，那到底是什么才是事件循环呢，这中间有发生了什么？</p><p>事件循环又被称为消息循环（message queue），是浏览器主线程的一种方式</p><p>在 Chorme 内部会开启一个永不结束的 for 循环，每次循环都会从消息队列中取第一个任务执行，而其他线程只需要在合适的时间将任务添加到队列的末尾，这里的其他线程，就是我们之前说到的网络请求，定时器等</p><p>在消息队列中，每一个任务都有不同的类型，同类型的任务必须在同一个队列（就比如，网络请求，就会放在网络请求的队列），不同的任务属于不同的队列，不同的任务有不同的优先级，在一次时间循环中，有浏览器决定哪一个队列的任务执行，但是浏览器必须有用完微任务队列，微任务有一定的优先级。</p>',11),n=[p];function s(_,c,i,l,d,h){return t(),a("div",null,n)}const S=e(r,[["render",s]]);export{u as __pageData,S as default};
